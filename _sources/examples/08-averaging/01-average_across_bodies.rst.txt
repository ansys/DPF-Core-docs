
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\08-averaging\01-average_across_bodies.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_08-averaging_01-average_across_bodies.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_08-averaging_01-average_across_bodies.py:


.. _ref_average_across_bodies:

Average across bodies
~~~~~~~~~~~~~~~~~~~~~
This example is aimed towards explaining how to activate or deactivate the averaging
across bodies option in DPF. When we have a multibody simulation that involves the
calculation of ElementalNodal fields, like stresses or strains, we can either
activate or deactivate the option of averaging theses fields across the different
bodies when they share common nodes. This will likely change the end results that are
displayed after the post processing of the simulation, as we will see below.

.. GENERATED FROM PYTHON SOURCE LINES 15-16

Let's start by importing the necessary modules.

.. GENERATED FROM PYTHON SOURCE LINES 16-21

.. code-block:: default


    from ansys.dpf import core as dpf
    from ansys.dpf.core import operators as ops
    from ansys.dpf.core import examples








.. GENERATED FROM PYTHON SOURCE LINES 22-23

Then we can load the simulation results from a .rst file and create a model of it.

.. GENERATED FROM PYTHON SOURCE LINES 23-28

.. code-block:: default


    analysis = examples.download_piston_rod()
    model = dpf.Model(analysis)
    print(model)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF Model
    ------------------------------
    Static analysis
    Unit system: MKS: m, kg, N, s, V, A, degC
    Physics Type: Mechanical
    Available results:
         -  displacement: Nodal Displacement
         -  reaction_force: Nodal Force   
         -  stress: ElementalNodal Stress 
         -  elemental_volume: Elemental Volume
         -  stiffness_matrix_energy: Elemental Energy-stiffness matrix
         -  artificial_hourglass_energy: Elemental Hourglass Energy
         -  thermal_dissipation_energy: Elemental thermal dissipation energy
         -  kinetic_energy: Elemental Kinetic Energy
         -  co_energy: Elemental co-energy
         -  incremental_energy: Elemental incremental energy
         -  elastic_strain: ElementalNodal Strain
         -  structural_temperature: ElementalNodal Temperature
    ------------------------------
    DPF  Meshed Region: 
      33337 nodes 
      18235 elements 
      Unit: m 
      With solid (3D) elements
    ------------------------------
    DPF  Time/Freq Support: 
      Number of sets: 3 
    Cumulative     Time (s)       LoadStep       Substep         
    1              1.000000       1              1               
    2              2.000000       2              1               
    3              3.000000       3              1               





.. GENERATED FROM PYTHON SOURCE LINES 29-32

Now, let's take a look at our system to see how our bodies are connected to
each other. First, we extract the mesh of our model and then we divide it into
different meshes using the split_mesh operator.

.. GENERATED FROM PYTHON SOURCE LINES 32-39

.. code-block:: default


    mesh = model.metadata.meshed_region
    split_mesh_op = ops.mesh.split_mesh(mesh=mesh, property="mat")
    meshes = split_mesh_op.outputs.meshes()

    meshes.plot(text="Body meshes")




.. image-sg:: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_001.png
   :alt: 01 average across bodies
   :srcset: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 40-43

As we can see in the image above, even though the piston rod is one single part,
it's composed of two different bodies. Additionally, we can observe that the region
where the two bodies are bonded together contains nodes that are common between them.

.. GENERATED FROM PYTHON SOURCE LINES 45-47

Now, let's take a look into how the averaging across bodies option alters the
results of a simulation.

.. GENERATED FROM PYTHON SOURCE LINES 49-54

Averaging across bodies with DPF
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Let's define two workflows. The first one does averaging across bodies, while the
second one doesn't. The variable of interest here is the stress in the Z direction,
which will be obtained using the "stress_Z" operator.

.. GENERATED FROM PYTHON SOURCE LINES 56-85

.. graphviz::

  digraph foo {
      graph [pad="0", nodesep="0.3", ranksep="0.3"]
      node [shape=box, style=filled, fillcolor="#ffcc0", margin="0"];
      rankdir=LR;
      splines=line;
      node [fixedsize=true,width=2.5]
      stress01 [label="stress_Z"];
      stress02 [label="stress_Z"];
      scp01 [label="split_on_property_type"];
      subgraph cluster_1 {
          ds01 [label="data_src", shape=box, style=filled, fillcolor=cadetblue2];
          ds01 -> scp01 [style=dashed];
          scp01 -> stress01;
          label="Averaging across bodies = Off";
          style=filled;
          fillcolor=lightgrey;
      }
      subgraph cluster_2 {
          ds02 [label="data_src", shape=box, style=filled, fillcolor=cadetblue2];
          inv02 [style=invisible]
          ds02 -> stress02 [style=dashed];
          stress02 -> inv02 [style=invis]
          label="Averaging across bodies = On";
          style=filled;
          fillcolor=lightgrey;
      }
  }

.. GENERATED FROM PYTHON SOURCE LINES 88-93

Averaging across bodies activated
---------------------------------
The extraction of the stresses in the Z direction in DPF applies by default averaging
across bodies. Therefore, a simple workflow like the one shown below can be used
in this case.

.. GENERATED FROM PYTHON SOURCE LINES 93-124

.. code-block:: default



    def average_across_bodies(analysis):
        # This function will extract the stresses in the Z direction (with the average
        # across bodies property activated) and plot them.

        # Create a model from the simulation results.
        model = dpf.Model(analysis)
        mesh = model.metadata.meshed_region

        # We're interested in the last time set, so:
        time_set = 3

        # Extracting the stresses in the Z direction. By default, DPF already applies
        # averaging across bodies when extracting the stresses.
        stress_op = ops.result.stress_Z()
        stress_op.inputs.connect(model)
        stress_op.inputs.time_scoping.connect(time_set)
        stress_op.inputs.requested_location.connect(dpf.locations.nodal)
        stresses = stress_op.outputs.fields_container()

        # Finding the maximum stress value
        min_max = dpf.operators.min_max.min_max_fc()
        min_max.inputs.fields_container.connect(stresses)
        max_val = min_max.outputs.field_max()

        mesh.plot(stresses, text="Averaged across bodies")

        return max(max_val.data)









.. GENERATED FROM PYTHON SOURCE LINES 125-131

Averaging across bodies deactivated
-----------------------------------
To extract the stresses without averaging across the bodies of the simulated
part, the workflow is a bit more complicated. So, instead of being presented
as a function, it will be broken into various parts with explanations of what
is being done.

.. GENERATED FROM PYTHON SOURCE LINES 133-135

First, we create a model from the simulation results and extract its mesh and
step informations.

.. GENERATED FROM PYTHON SOURCE LINES 135-140

.. code-block:: default

    model = dpf.Model(analysis)
    mesh = model.metadata.meshed_region
    time_freq = model.metadata.time_freq_support
    time_sets = time_freq.time_frequencies.data.tolist()








.. GENERATED FROM PYTHON SOURCE LINES 141-143

We need to split the meshes of the two bodies so we can then create separate
scopings for each one of them. The 'mat' label is used to split the mesh by bodies.

.. GENERATED FROM PYTHON SOURCE LINES 143-146

.. code-block:: default

    mesh_scop_op = ops.scoping.split_on_property_type(mesh=mesh, label1="mat")
    mesh_scop_cont = mesh_scop_op.outputs.mesh_scoping()








.. GENERATED FROM PYTHON SOURCE LINES 147-149

Then, as we have 3 different time steps, we need to create a ScopingsContainer
that contains the meshes of each one of these steps. We do so as follows:

.. GENERATED FROM PYTHON SOURCE LINES 149-162

.. code-block:: default


    scop_cont = dpf.ScopingsContainer()
    scop_cont.add_label("body")
    scop_cont.add_label("time")
    for tset in time_sets:
        body = 1
        for mesh_scop in mesh_scop_cont:
            scop_cont.add_scoping(
                scoping=mesh_scop, label_space={"body": body, "time": int(tset)}
            )
            body += 1
    print(scop_cont)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF Scopings Container with
            6 scoping(s)
            defined on labels ['body', 'time'] 






.. GENERATED FROM PYTHON SOURCE LINES 163-166

As we can see, we've got 6 different Scopings inside our ScopingsContainer, one for
each body over each one of the three time steps. Let's now focus our analysis on the
last time set:

.. GENERATED FROM PYTHON SOURCE LINES 166-168

.. code-block:: default

    time_set = 3








.. GENERATED FROM PYTHON SOURCE LINES 169-173

Then, to retrieve the Z stresses without averaging across the two bodies, we can pass
a ScopingsContainer that contains their respective meshes as a parameter to the
stress_Z operator. To be able to do that, we need a new ScopingsContainer that contains
the meshes of the two bodies in the desired time step.

.. GENERATED FROM PYTHON SOURCE LINES 173-182

.. code-block:: default


    scop_list = scop_cont.get_scopings(label_space={"time": time_set})
    scopings = dpf.ScopingsContainer()
    scopings.add_label("body")
    body = 1
    for scop in scop_list:
        scopings.add_scoping(label_space={"body": body}, scoping=scop)
        body += 1
    print(scopings)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF Scopings Container with
            2 scoping(s)
            defined on labels ['body'] 






.. GENERATED FROM PYTHON SOURCE LINES 183-185

We can see that, in this container, we only have two Scopings, one for each body
in the last time step, as desired.

.. GENERATED FROM PYTHON SOURCE LINES 187-188

Finally, we can extract the stresses in the Z direction.

.. GENERATED FROM PYTHON SOURCE LINES 188-198

.. code-block:: default


    stress_op = ops.result.stress_Z()
    stress_op.inputs.connect(model)
    stress_op.inputs.time_scoping.connect(time_set)
    stress_op.inputs.mesh_scoping.connect(
        scopings
    )  # This option deactivates averaging across bodies.
    stress_op.inputs.requested_location.connect(dpf.locations.nodal)
    stresses = stress_op.outputs.fields_container()
    print(stresses)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF stress(s)Fields Container
      with 2 field(s)
      defined on labels: body time 

      with:
      - field 0 {body:  1, time:  3} with Nodal location, 1 components and 17281 entities.
      - field 1 {body:  2, time:  3} with Nodal location, 1 components and 17610 entities.





.. GENERATED FROM PYTHON SOURCE LINES 199-200

Additionally, we can find the maximum value of the stress field for comparison purposes.

.. GENERATED FROM PYTHON SOURCE LINES 200-204

.. code-block:: default


    min_max = dpf.operators.min_max.min_max_fc()
    min_max.inputs.fields_container.connect(stresses)
    max_val = min_max.outputs.field_max()







.. GENERATED FROM PYTHON SOURCE LINES 205-206

We can also define the workflow presented above as a function:

.. GENERATED FROM PYTHON SOURCE LINES 206-258

.. code-block:: default



    def not_average_across_bodies(analysis):
        # This function will extract the stresses in the Z direction (with the average
        # across bodies option deactivated) and plot them.

        model = dpf.Model(analysis)
        mesh = model.metadata.meshed_region

        time_freq = model.metadata.time_freq_support
        time_sets = time_freq.time_frequencies.data.tolist()

        mesh_scop_op = ops.scoping.split_on_property_type(mesh=mesh, label1="mat")
        mesh_scop_cont = mesh_scop_op.outputs.mesh_scoping()

        scop_cont = dpf.ScopingsContainer()
        scop_cont.add_label("body")
        scop_cont.add_label("time")
        for tset in time_sets:
            body = 1
            for mesh_scop in mesh_scop_cont:
                scop_cont.add_scoping(
                    scoping=mesh_scop, label_space={"body": body, "time": int(tset)}
                )
                body += 1

        time_set = 3

        scop_list = scop_cont.get_scopings(label_space={"time": time_set})
        scopings = dpf.ScopingsContainer()
        scopings.add_label("body")
        body = 1
        for scop in scop_list:
            scopings.add_scoping(label_space={"body": body}, scoping=scop)
            body += 1

        stress_op = ops.result.stress_Z()
        stress_op.inputs.connect(model)
        stress_op.inputs.time_scoping.connect(time_set)
        stress_op.inputs.mesh_scoping.connect(scopings)
        stress_op.inputs.requested_location.connect(dpf.locations.nodal)
        stresses = stress_op.outputs.fields_container()

        min_max = dpf.operators.min_max.min_max_fc()
        min_max.inputs.fields_container.connect(stresses)
        max_val = min_max.outputs.field_max()

        meshes.plot(stresses, text="Not averaged across bodies")

        return max(max_val.data)









.. GENERATED FROM PYTHON SOURCE LINES 259-264

Plotting the results
~~~~~~~~~~~~~~~~~~~~
Finally, let's plot the results to see how they compare. In the first image, we have
the stress distribution when the averaging across bodies options is activated, while
in the second one it's deactivated.

.. GENERATED FROM PYTHON SOURCE LINES 264-268

.. code-block:: default


    max_avg_on = average_across_bodies(analysis)
    max_avg_off = not_average_across_bodies(analysis)




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_002.png
          :alt: 01 average across bodies
          :srcset: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_002.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_003.png
          :alt: 01 average across bodies
          :srcset: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_003.png
          :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 269-284

.. code-block:: default

    diff = abs(max_avg_on - max_avg_off) / max_avg_off * 100
    print(
        "Max stress when averaging across bodies is activated: {:.2f} Pa".format(max_avg_on)
    )
    print(
        "Max stress when averaging across bodies is deactivated: {:.2f} Pa".format(
            max_avg_off
        )
    )
    print(
        "The maximum stress value when averaging across bodies is ACTIVATED \
    is {:.2f}% LOWER than when it is DEACTIVATED".format(
            diff
        )
    )




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Max stress when averaging across bodies is activated: 6958243299.56 Pa
    Max stress when averaging across bodies is deactivated: 6988756864.00 Pa
    The maximum stress value when averaging across bodies is ACTIVATED is 0.44% LOWER than when it is DEACTIVATED





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  14.961 seconds)


.. _sphx_glr_download_examples_08-averaging_01-average_across_bodies.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 01-average_across_bodies.py <01-average_across_bodies.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 01-average_across_bodies.ipynb <01-average_across_bodies.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
